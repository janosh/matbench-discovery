# %%
import warnings
from datetime import datetime

import pandas as pd
from aviary.wren.utils import get_aflow_label_from_spglib
from pymatgen.entries.compatibility import MaterialsProject2020Compatibility
from pymatgen.entries.computed_entries import ComputedStructureEntry
from tqdm import tqdm

from matbench_discovery import ROOT
from matbench_discovery.data import as_dict_handler
from matbench_discovery.energy import get_e_form_per_atom

"""
Change JSON orientation of wbm-cleaned.json.gz and WBM step IDs to match the dielectric
Pareto frontier project.

NOTE Don't use the data files generated by this file. The input ComputedStructureEntries
receveid from Rhys appear to have energy corrections baked into the uncorrected energy.
"""

__author__ = "Janosh Riebesell"
__date__ = "2022-06-26"

today = f"{datetime.now():%Y-%m-%d}"


def increment_wbm_material_id(wbm_id: str) -> str:
    """Turns 'step_1-0' into 'wbm-step-1-1' etc."""
    *_, step_num, material_num = wbm_id.split("_")

    assert step_num.isdigit() and material_num.isdigit()

    return f"wbm-step-{step_num}-{int(material_num) + 1}"


# %%
df_wbm = pd.read_json(
    f"{ROOT}/data/2022-06-11-from-rhys/wbm-cleaned.json.gz", orient="split"
).set_index("material_id")
df_wbm.index = df_wbm.index.map(increment_wbm_material_id)

df_wbm = df_wbm.rename(columns=dict(bandgap="bandgap_pbe"))

df_wbm["cse"] = [ComputedStructureEntry.from_dict(x) for x in tqdm(df_wbm.cse)]

for wbm_id, cse in tqdm(df_wbm.cse.items()):
    cse.entry_id = wbm_id

df_wbm["energy"] = [cse.energy for cse in df_wbm.cse]
df_wbm["n_sites"] = [len(cse.structure) for cse in df_wbm.cse]
df_wbm["formula"] = [cse.structure.formula for cse in df_wbm.cse]


# %%
df_wbm.reset_index().to_json(
    f"{ROOT}/data/{today}-wbm-cses-and-initial-structures.json.gz",
    default_handler=as_dict_handler,
)

# df_wbm = pd.read_json(
#     f"{ROOT}/data/2022-06-26-wbm-cses-and-initial-structures.json.gz"
# ).set_index("material_id")


# %% compute WBM formation energies and Aflow-style Wyckoff labels
# warning: slow (takes ~15 min)
df_wbm["wyckoff"] = [
    get_aflow_label_from_spglib(cse.structure) for cse in tqdm(df_wbm.cse)
]


# using ComputedStructureEntries vs ComputedEntries to compute formation energies makes
# a noticeable difference in several thousand compounds all of which are oxides and
# sulfides.
wbm_computed_struct_entries = [
    ComputedStructureEntry.from_dict(x) for x in tqdm(df_wbm.cse)
]


# without filter, process_entries() prints so many warnings it can crash Jupyter kernel
warnings.filterwarnings(action="ignore", category=UserWarning, module="pymatgen")

processed_entries = MaterialsProject2020Compatibility().process_entries(
    wbm_computed_struct_entries, verbose=True, clean=True
)
assert len(processed_entries) == len(wbm_computed_struct_entries)

df_wbm["e_form_per_atom_from_cse"] = [
    get_e_form_per_atom(entry) for entry in tqdm(wbm_computed_struct_entries)
]


# %%
# filter outliers with anomalously high formation energies
max_e_form = 3  # eV/atom
print(
    f"imposing {max_e_form = }eV/atom filters "
    f"{sum(df_wbm.e_form_per_atom > max_e_form)} materials"
)
# >>> max_e_form = 3eV/atom filters 26 materials
df_wbm.drop(columns=["initial_structure", "cse"], errors="ignore").query(
    f"e_form_per_atom < {max_e_form}"
).to_csv(f"{ROOT}/data/{today}-wbm-formation-energy+wyckoff.csv")

ax = df_wbm.query("e_form_per_atom < 10").e_form_per_atom.plot.hist(bins=200, log=True)
ax.axvline(x=max_e_form, color="red", linestyle="--", label=f"{max_e_form} eV/atom")
ax.legend(frameon=False)


# %% 2022-07-18 also increment material_ids in all the CSVs containing model
# predictions and wbm-e-above-mp-hull.csv
for filename in tqdm(
    "wbm-e-above-mp-hull",
    "wren-mp-initial-structures",
    "cgcnn-mp-initial-structures",
    "voronoi-mp-initial-structures",
    "wren-mp-cse",
    "cgcnn-mp-cse",
    "voronoi-mp-cse",
):
    file_path = f"{ROOT}/data/2022-06-11-from-rhys/{filename}.csv"

    df = pd.read_csv(file_path).round(5)

    df["material_id"] = df.material_id.map(increment_wbm_material_id)

    df.to_csv(file_path, index=False)
